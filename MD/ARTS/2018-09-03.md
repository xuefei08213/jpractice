

## Alogrithom
### Problem:  [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/)
### Tags: 
### Difficulty: Easy
### Description
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.


### Example
    Example 1:

    Input: 2
    Output: 2
    Explanation: There are two ways to climb to the top.
    1. 1 step + 1 step
    2. 2 steps
    
    Example 2:

    Input: 3
    Output: 3
    Explanation: There are three ways to climb to the top.
    1. 1 step + 1 step + 1 step
    2. 1 step + 2 steps
    3. 2 steps + 1 step
    
### Solution by Java

At first,i don't konw how to do this algorithm except draw a graphic like below.Then i enter the discuss moudle to study the idea of the others.Fortunately,i saw an idea about [Fibonacci](https://leetcode.com/problems/climbing-stairs/discuss/25645/I-want-to-ask-how-do-you-figure-this-relation-out.-Can-anyone-explain-it-literally).And someone explain：

    In practical terms, if you are solving for n>2 you can take your result from the previous step (n-1) and the only way you 
    can get to n is to take one step. So that gives us f(n-1) combinations. But you could also have taken a two step jump to 
    your current position of n. So if we think back that is the same idea, just using f(n-2). So the full function is 
    f(n)=f(n-1)+f(n-2).
    
According to above idea,i complete my first version in Solition 1.

#### Solution 1

````java
    public int climbStairs(int n) {
        int result = 0;
        if (1 == n) {
            return 1;
        }
        if (2 == n) {
            return 2;
        }
        result = climbStairs(n - 1) + climbStairs(n - 2);
        return result;
    }
````

This solution can solve the question,the letcode show 'Time Limit Exceeded',and i know the reason until i write this article.
After commit the submission,i go to the solution module,to study the method proviced by letcode.

#### Solution 2 

##### Brute Force

````java
public class Solution {
    public int climbStairs(int n) {
        climb_Stairs(0, n);
    }
    public int climb_Stairs(int i, int n) {
        if (i > n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n);
    }
}
````
##### Complexity Analysis

### Solution3 Dynamic Programming

#### Algorithm

As we can see this problem can breaken into subproblems,and it contain the optimal substructure property.  
i.e. its optimal solution can be constructed efficiently from optimal solutions of its subproblems, we can use dynamic   programming to solve this problem. 

````java
public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
````


## Review
[Constructors Are Not Thread-Safe](http://bruceeckel.github.io/2017/01/13/constructors-are-not-thread-safe/)


## Technique

### SpringBoot中的Mongo内存数据库
#### 问题来源


#### 解决方案：


#### 代码展示

## Share
